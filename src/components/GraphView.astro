---
// GraphView.astro
import fs from 'fs';
import path from 'path';
import matter from 'gray-matter';

// Leggi i post dalla cartella src/data/blog
const blogDir = path.join(process.cwd(), 'src/data/blog');
const files = fs.readdirSync(blogDir).filter(file => file.endsWith('.md'));

const posts = files.map(file => {
  const content = fs.readFileSync(path.join(blogDir, file), 'utf-8');
  const { data } = matter(content);
  return {
    slug: file.replace('.md', ''),
    title: data.title || 'Senza titolo',
    tags: data.tags || []
  };
});

// Conta quanti post ha ogni tag
const tagCounts = new Map();
posts.forEach(post => {
  post.tags.forEach(tag => {
    tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
  });
});

// Crea nodi per ogni tag
const nodes = Array.from(tagCounts.entries()).map(([tag, count]) => ({
  id: tag,
  name: tag,
  val: count + 3,
  count: count
}));

// Crea collegamenti tra tag che compaiono insieme
const links = [];
const linkMap = new Map();

posts.forEach(post => {
  const postTags = post.tags;
  for (let i = 0; i < postTags.length; i++) {
    for (let j = i + 1; j < postTags.length; j++) {
      const tag1 = postTags[i];
      const tag2 = postTags[j];
      const linkId = [tag1, tag2].sort().join('::');
      
      if (!linkMap.has(linkId)) {
        linkMap.set(linkId, 0);
      }
      linkMap.set(linkId, linkMap.get(linkId) + 1);
    }
  }
});

linkMap.forEach((count, linkId) => {
  const [source, target] = linkId.split('::');
  links.push({
    source,
    target,
    value: count
  });
});

const graphData = { nodes, links };
---

<div id="graph-wrapper">
  <div id="graph-container"></div>
  <div id="graph-info">
    <p>{nodes.length} tag â€¢ {links.length} collegamenti</p>
  </div>
</div>

<style>
  #graph-wrapper {
    width: 100%;
    height: calc(100vh - 80px);
    position: relative;
    background: var(--color-background);
  }

  #graph-container {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: hidden;
  }
  
  #graph-info {
    position: absolute;
    top: 20px;
    left: 20px;
    background: var(--color-muted);
    color: var(--color-foreground);
    padding: 10px 15px;
    border-radius: 6px;
    font-size: 14px;
    z-index: 10;
    pointer-events: none;
    border: 1px solid var(--color-border);
  }
</style>

<script src="https://unpkg.com/force-graph@1.43.0/dist/force-graph.min.js"></script>

<script define:vars={{ graphData }}>
  function getThemeColors() {
    const style = getComputedStyle(document.documentElement);
    return {
      background: style.getPropertyValue('--color-background').trim(),
      foreground: style.getPropertyValue('--color-foreground').trim(),
      accent: style.getPropertyValue('--color-accent').trim(),
      muted: style.getPropertyValue('--color-muted').trim(),
      border: style.getPropertyValue('--color-border').trim()
    };
  }

  function initGraph() {
    const container = document.getElementById('graph-container');
    
    if (container && window.ForceGraph) {
      const colors = getThemeColors();
      
      const graph = window.ForceGraph()(container)
        .graphData(graphData)
        .nodeLabel(node => `${node.name} (${node.count} post)`)
        .nodeVal('val')
        .nodeColor(() => colors.accent)
        .nodeCanvasObject((node, ctx, globalScale) => {
          const label = node.name;
          const fontSize = 12/globalScale;
          ctx.font = `${fontSize}px monospace`;
          const textWidth = ctx.measureText(label).width;
          const bckgDimensions = [textWidth, fontSize].map(n => n + fontSize * 0.2);

          // Sfondo del nodo con colore accent
          ctx.fillStyle = colors.accent;
          ctx.fillRect(
            node.x - bckgDimensions[0] / 2,
            node.y - bckgDimensions[1] / 2,
            bckgDimensions[0],
            bckgDimensions[1]
          );

          // Testo con colore background (contrasto)
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = colors.background;
          ctx.fillText(label, node.x, node.y);
          
          node.__bckgDimensions = bckgDimensions;
        })
        .nodePointerAreaPaint((node, color, ctx) => {
          ctx.fillStyle = color;
          const bckgDimensions = node.__bckgDimensions;
          bckgDimensions && ctx.fillRect(
            node.x - bckgDimensions[0] / 2,
            node.y - bckgDimensions[1] / 2,
            ...bckgDimensions
          );
        })
        .linkColor(() => colors.muted)
        .linkWidth(link => Math.sqrt(link.value))
        .backgroundColor(colors.background)
        .onNodeClick((node) => {
          window.location.href = `/tags/${node.id}`;
        })
        .onNodeHover((node) => {
          container.style.cursor = node ? 'pointer' : 'default';
        });

      // Aggiorna i colori quando cambia il tema
      const observer = new MutationObserver(() => {
        const newColors = getThemeColors();
        graph
          .nodeColor(() => newColors.accent)
          .linkColor(() => newColors.muted)
          .backgroundColor(newColors.background);
      });

      observer.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['data-theme']
      });
    }
  }

  if (document.readyState === 'loading') {
    window.addEventListener('DOMContentLoaded', initGraph);
  } else {
    initGraph();
  }
</script>